<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>STACKSWORTH — Timechain Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0b0f14;          /* deep tech noir */
      --panel:#0f1720cc;     /* glassy panel */
      --muted:#94a3b8;       /* slate */
      --txt:#e2e8f0;         /* light */
      --accent:#ffa600;      /* cyan neon */
      --accent-2:#ff42a1;    /* magenta neon */
      --accent-3:#ffa600;    /* amber */
      --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444;
      --glow-color: rgba(255,166,0,.35);
      --bar1: rgba(255,166,0,.6); --bar2: rgba(255,166,0,.1);
      --accent-alt:#00f6ff;         /* opposite accent for highlights */
      --glow-alt-color: rgba(0,246,255,.35);
      --glow: drop-shadow(0 0 12px var(--glow-color));
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:radial-gradient(1200px 800px at 110% -10%, #0c1b2a 0%, transparent 50%),
              radial-gradient(1200px 800px at -10% 110%, #22112a 0%, transparent 50%),
              var(--bg);
      color:var(--txt); font-family:"Chakra Petch", system-ui, sans-serif;
      letter-spacing:.2px;
    }
    /* Light mode overrides */
    .light{
      --bg:#f5f7fb;
      --panel:#ffffffee;
      --muted:#475569;
      --txt:#0b1220;
      --glow-color: rgba(255,166,0,.40);
      --bar1: rgba(255,166,0,.55); --bar2: rgba(255,166,0,.15);
    }

    .scanlines:before{
      content:""; position:fixed; inset:0; pointer-events:none;
      background: repeating-linear-gradient(
        to bottom, rgba(255,255,255,.06), rgba(255,255,255,.06) 1px,
        transparent 1px, transparent 3px
      ); mix-blend-mode:overlay; opacity:.05; z-index:1
    }
    header{
      position:sticky; top:0; z-index:2; backdrop-filter: blur(10px);
      background: linear-gradient(90deg, #09121a 0%, transparent 30%, transparent 70%, #120913 100%);
      border-bottom:1px solid #1f2a37; padding:14px 22px; display:flex; align-items:center; gap:18px
    }
    .logo{font-weight:700; font-size:20px; letter-spacing:2px}
    .badge{padding:4px 10px; border:1px solid #243142; border-radius:999px; color:var(--muted)}
    .accent{color:var(--accent); filter:var(--glow)}
    main{padding:20px; max-width:1400px; margin:0 auto}
    .grid{display:grid; grid-template-columns: repeat(12, 1fr); gap:18px}
    .card{
      background:linear-gradient(180deg, rgba(20,25,34,.8), rgba(10,14,20,.6));
      border:1px solid #1f2a37; border-radius:var(--radius);
      padding:16px; position:relative; overflow:hidden
    }
    .card:after{content:""; position:absolute; inset:0; pointer-events:none;
      background:radial-gradient(500px 300px at 120% -20%, rgba(0,246,255,.08), transparent 40%),
                 radial-gradient(500px 300px at -20% 120%, rgba(255,66,161,.08), transparent 40%)}
    .title{display:flex; align-items:center; justify-content:space-between; margin-bottom:10px}
    .title h3{margin:0; font-size:14px; text-transform:uppercase; letter-spacing:1.5px; color:#cbd5e1}
    .value{font-size:32px; font-weight:700; line-height:1}
    .sub{font-size:14px; color:var(--muted)}
    .row{display:flex; align-items:center; gap:10px; flex-wrap:wrap}
    .pill{border:1px solid #243142; padding:6px 10px; border-radius:999px; font-size:12px; color:#cbd5e1}
    .spark{height:36px; width:100%;}

    /* SVG mini sparkline */
    .spark svg{width:100%; height:100%}
    .spark path{stroke:var(--accent); fill:transparent; filter:var(--glow)}
    /* Use opposite accent for price sparkline and miner name */
    #card-price .spark polyline{stroke:var(--accent-alt)}
    #miner.accent{color:var(--accent-alt); filter: drop-shadow(0 0 12px var(--glow-alt-color));}

    /* Price per satoshi */
    .sats-per-usd {
      color: var(--accent);
      font-weight: 700;
      font-size: 15px;
      letter-spacing: 0.5px;
      filter: drop-shadow(0 0 6px var(--glow-color));
      margin-top: 12px;
      display: block;
    }

    /* Circular arc gauge */
    .gauge{width:120px; height:120px; position:relative}
    .gauge .ring{position:absolute; inset:0; border-radius:50%;
      background:
        conic-gradient(var(--accent) var(--pct), #1f2a37 var(--pct));
      -webkit-mask: radial-gradient(circle 46px at 50% 50%, transparent 46px, black 47px);
              mask: radial-gradient(circle 46px at 50% 50%, transparent 46px, black 47px);
      border:1px solid #223047
    }
    .gauge .center{position:absolute; inset:0; display:grid; place-items:center}
    .gauge .center b{font-family:"JetBrains Mono", monospace; font-size:18px}
    .gauge .center span{font-size:12px; color:var(--muted)}

    /* Bar strip for block intervals */
    .bars{display:flex; gap:6px; align-items:flex-end; height:90px}
    .barwrap{flex:1; display:flex; flex-direction:column; align-items:center; justify-content:flex-end}
    .barlbl{font-size:10px; color:var(--muted); margin-top:4px; line-height:1}
    .bars .bar{width:100%; background:linear-gradient(180deg, var(--bar1), var(--bar2));
      filter:var(--glow); border-radius:6px 6px 2px 2px; border:1px solid #1f2a37}
    

    /* Footer wide cards */
    .col-3{grid-column: span 3}
    .col-4{grid-column: span 4}
    .col-6{grid-column: span 6}
    .col-8{grid-column: span 8}
    .col-12{grid-column: 1 / -1}
    @media (max-width: 1100px){.col-6,.col-8{grid-column: span 12}}
    @media (max-width: 800px){.col-3,.col-4{grid-column: span 12}}

    /* Soft neon button */
    .btn{cursor:pointer; font-size:12px; padding:8px 12px; border-radius:10px;
      border:1px solid #203043; color:var(--txt); background: #0b1220; transition:.2s}
    .btn:hover{border-color:#2f4b66; box-shadow:0 0 0 2px rgba(0,246,255,.1)}

    /* Tiny legend dots */
    .dot{display:inline-block; width:10px; height:10px; border-radius:999px; margin-right:6px}
  /* mini btn + bar label tweaks */
    .btn.mini{padding:4px 8px; font-size:11px}
    .btn[disabled]{opacity:.45; cursor:default; box-shadow:none}
    .barlbl b{font-size:10px}
    .barlbl .ht{font-size:9px; color:var(--muted); opacity:.85; margin-top:2px}
  </style>
</head>
<body class="scanlines">
  <header>
    <div class="logo"><span class="accent">STACKSWORTH</span> // TIMECHAIN</div>
    <span class="badge">v0.0.4 HTML Preview</span>
    <span class="badge">Data: live (price, 24h, latest block, Block Visualizer)</span>
    <div style="margin-left:auto" class="row">
      <button class="btn" id="refresh">Refresh</button>
      <button class="btn" id="theme">Accent</button>
      <button class="btn" id="mode">Mode</button>
    </div>
  </header>

  <main>
    <div class="grid">
      <!-- BTC PRICE CARD -->
      <section class="card col-4" id="card-price">
        <div class="title"><h3>BTC / USD</h3><span class="pill" id="price-change">24h: --</span></div>
        <div class="value" id="price" style="margin-bottom:10px;">$--</div>
        <div class="sub" id="price-sub" style="margin-bottom:20px;">CAD est: --  ·  Last update --</div>
        <div class="spark" id="sparkline"></div>
        <div class="sub sats-per-usd" id="sats-per-usd">— SATS / $1 USD</div>
        <div class="sub" id="sats-per-cad">— SATS / $1 CAD</div>
      </section>

      <!-- BLOCK HEIGHT & MINER -->
      <section class="card col-4">
        <div class="title"><h3>Latest Block</h3><span class="pill" id="block-age">age --</span></div>
        <div class="value" id="block-height">Block --</div>
        <div class="sub">Mined by <span id="miner" class="accent">—</span></div>
        <div class="bars" id="interval-bars" style="margin-top:10px"></div>
        <div class="row" style="justify-content:space-between; margin-top:6px">
          <div class="sub">Time between blocks (min)</div>
          <div class="row" style="gap:6px">
            <button class="btn mini" id="bars-left">◀</button>
            <button class="btn mini" id="bars-right">▶</button>
            <button class="btn mini" id="bars-latest" style="display:none" title="Jump to latest">⏭</button>
          </div>
        </div>
      </section>

      <!-- FEES & MEMPOOL GAUGE -->
      <section class="card col-4">
        <div class="title"><h3>Mempool / Fees</h3><span class="pill" id="tx-backlog">—</span></div>
        <div class="row" style="justify-content:space-between">
          <div>
            <div class="row" style="gap:12px">
              <span class="pill"><span class="dot" style="background:var(--ok)"></span>Low <b id="fee-low">—</b> sat/vB</span>
              <span class="pill"><span class="dot" style="background:var(--warn)"></span>Med <b id="fee-med">—</b></span>
              <span class="pill"><span class="dot" style="background:var(--bad)"></span>High <b id="fee-high">—</b></span>
            </div>
            <div class="sub" style="margin-top:8px">vMB backlog: <b id="vmb">—</b></div>
          </div>
          <div class="gauge" id="mempool-gauge" style="--pct: 35%">
            <div class="ring"></div>
            <div class="center"><div>
              <b id="gauge-pct">35%</b><br/>
              <span>Capacity</span>
            </div></div>
          </div>
        </div>
      </section>

      <!-- HASHRATE / DIFFICULTY SNAPSHOT -->
      <section class="card col-3" id="card-hashrate">
        <div class="title"><h3>Hashrate</h3><span class="pill">est</span></div>
        <div class="value" id="hashrate">— EH/s</div>
</section>

      <!-- DOMINANCE / MARKET CAP SNAPSHOT -->
      <section class="card col-3">
        <div class="title"><h3>Market</h3><span class="pill">macro</span></div>
        <div class="value" id="dominance">—% dom</div>
        <div class="sub">Cap: <span id="market-cap">—</span></div>
      </section>

      <!-- 24H PRICE CHART (WIDE) -->
      <section class="card col-6">
        <div class="title"><h3>Price — 24h</h3><span class="pill" id="chart-meta">24h • live</span></div>
        <div id="chart-24h" style="height:180px"></div>
        <div class="row" style="margin-top:8px">
          <span class="pill">Low 24h: <b id="low24">—</b></span>
          <span class="pill">High 24h: <b id="high24">—</b></span>
          <span class="pill">Vol 24h: <b id="vol24">—</b></span>
        </div>
      </section>

      <!-- FOOTER: BLOCK INTERVAL VISUALIZER (WIDE) -->
      <section class="card col-12">
        <div class="title"><h3>Block Interval Visualizer</h3><span class="pill">target 10min</span></div>
        <div id="interval-canvas" style="height:180px"></div>
        <div class="sub">Each column = minutes between blocks; center line = 10m target.</div>
      </section>
    </div>
  </main>

  <script>


const SATONAK = 'https://satonak.bitcoinmanor.com';
const API_BASE = 'https://mempool.space/api';
 

    // ===== API CONFIG  =====
const API = {
  price: `${SATONAK}/v1/price`, 
  chart24h: 'https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=usd&days=1',
  blocks: `${SATONAK}/v1/blocks?limit=13`, // fetch latest 13 blocks
  miner: `${SATONAK}/v1/miner`,          // fetch latest block miner info
  blocksExtras: null // optional on some self-hosted instances; public mempool.space returns 404
};
 

// ===== Miner identification (fallback via coinbase tag) =====
const POOL_TAGS = [
  { match: /f2pool/i, name: 'F2Pool' },
  { match: /antpool/i, name: 'AntPool' },
  { match: /viabtc/i, name: 'ViaBTC' },
  { match: /poolin/i, name: 'Poolin' },
  { match: /btc\.com|btccom/i, name: 'BTC.com' },
  { match: /binance/i, name: 'Binance Pool' },
  { match: /carbon/i, name: 'Carbon Negative' },
  { match: /slush|braiins/i, name: 'Braiins Pool' },
  { match: /foundry/i, name: 'Foundry USA' },
  { match: /ocean/i, name: 'Ocean Pool' },
  { match: /mara|marathon|marapool/i, name: 'Marathon' },
  { match: /luxor/i, name: 'Luxor' },
  { match: /ultimus/i, name: 'ULTIMUSPOOL' },
  { match: /novablock/i, name: 'NovaBlock' },
  { match: /sigma/i, name: 'SigmaPool' },
  { match: /spider/i, name: 'SpiderPool' },
  { match: /tera/i, name: 'TERA Pool' },
  { match: /okex|okx/i, name: 'OKX Pool' },
  { match: /kucoin/i, name: 'KuCoin Pool' },
  { match: /sbi/i, name: 'SBI Crypto' },
  { match: /btc\.top|btctop/i, name: 'BTC.TOP' },
  { match: /emcd/i, name: 'EMCD Pool' },
  { match: /secpool/i, name: 'SECPOOL' },
  { match: /hz[ _-]?pool/i, name: 'HZ Pool' },
  { match: /solo\.ckpool/i, name: 'Solo CKPool' },
  { match: /solopool/i, name: 'Solo Pool' },
  { match: /bitaxe|\/axe\//i, name: 'Bitaxe Solo Miner' },
  { match: /node\.pw/i, name: 'Node.PW' },
  { match: /braiins/i, name: 'Braiins Pool' },
  { match: /solo/i, name: 'Solo Miner' }
];

const MINER_CACHE = {};
const DETAILS_CACHE = {}; // hash -> { sizeBytes, txCount }
const DETAILS_FETCHING = new Set();

function hexToAscii(hex){
  if(!hex || typeof hex !== 'string') return '';
  let out='';
  for(let i=0;i<hex.length;i+=2){
    const code = parseInt(hex.substr(i,2), 16);
    if(!Number.isNaN(code)) out += String.fromCharCode(code);
  }
  return out;
}

function identifyPoolFromCoinbase(text){
  if(!text) return null;
  for(const p of POOL_TAGS){
    if(p.match.test(text)) return p.name;
  }
  return null;
}

function codeFromName(name){
  if(!name) return '';
  const MAP = {
    'Foundry USA':'FND','AntPool':'ANT','F2Pool':'F2P','ViaBTC':'VIA','Poolin':'PLN','BTC.com':'BTC',
    'Binance Pool':'BNZ','Braiins Pool':'BRN','Luxor':'LUX','Marathon':'MAR','OKX Pool':'OKX','KuCoin Pool':'KUC',
    'SBI Crypto':'SBI','BTC.TOP':'BTCT','EMCD Pool':'EMCD','NovaBlock':'NVB','SigmaPool':'SIG','SpiderPool':'SPD',
    'TERA Pool':'TER','Ocean Pool':'OCN','SECPOOL':'SEC','HZ Pool':'HZ','Solo CKPool':'CKP','Solo Pool':'SLO',
    'Solo Miner':'SLO','Carbon Negative':'CRB','ULTIMUSPOOL':'ULT','Node.PW':'NPW','Bitaxe Solo Miner':'BAX'
  };
  if(MAP[name]) return MAP[name];
  const letters = (name.match(/[A-Z0-9]+/gi)||[]).join('');
  return letters.substring(0,3).toUpperCase();
}

const S = {
      priceUSD: 67234,
      priceCAD: 89654,
      change24: +2.84,
      spark: Array.from({length: 40}, (_,i)=> 1 + Math.sin(i/6)*.8 + Math.random()*.5),
      blockHeight: null,
      blockAgeMin: null,
      miner: null,
      intervals: [],
      fees: {low:4, med:7, high:15, vmb: 85, backlogTx: 178_000, capacityPct: 35},
      hashrate: null,
      hashrate24hChange: null,
      difficulty: null,
      difficultyChange: null,
      difficultyDaysAgo: null,
      dominance: 54.2,
      marketCap: 1.33,
      chart24: Array.from({length: 96}, (_,i)=> 66800 + Math.sin(i/8)*400 + (Math.random()-0.5)*140),
      blockHash: null,
      blockTsSec: null,
      intervalMinersFull: [],
      intervalMinersCode: [],
      intervalMinerHashes: [],
      intervalHeights: [],
      barWindow: { start: 0, size: 7 },
      _blocksCache: []
    };

    // ===== HELPER RENDERERS =====


    // ===== FETCHERS (Price + 24h change) =====
let tPrice = null, tChart = null, tBlock = null, tBlockAge = null;

async function fetchPriceAndChange(){
  try{
    // Fetch BTC price in USD from SatoNak
    const rUSD = await fetch(`${SATONAK}/v1/price?fiat=USD`, { headers: { accept:'application/json' }});
    if(!rUSD.ok) throw new Error('USD HTTP '+rUSD.status);
    const usd = await rUSD.json();

    // Fetch BTC price in CAD from SatoNak (for “CAD est” + sats/$CAD)
    const rCAD = await fetch(`${SATONAK}/v1/price?fiat=CAD`, { headers: { accept:'application/json' }});
    if(!rCAD.ok) throw new Error('CAD HTTP '+rCAD.status);
    const cad = await rCAD.json();

    // Map into your state (S)
    S.priceUSD = Number(usd?.value) || null;
    S.priceCAD = Number(cad?.value) || null;

    // SatoNak doesn’t return 24h % yet; show “—” for now
    S.change24 = null;

    // Render the price card + sats/$
    renderPrice();
  }catch(err){
    console.warn('[price from SatoNak] fetch failed:', err);
  }
}

    //Fetch chart data for the last 24 hours
async function fetchChart24h(){
  try{
    const r = await fetch(API.chart24h, { headers: { 'accept':'application/json' }});
    if(!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();
    const prices = (j.prices||[]).map(p=> p[1]);
    const vols = (j.total_volumes||[]).map(v=> v[1]); // USD volume (since vs_currency=usd)
    if(prices && prices.length){
      S.chart24 = prices;
      // also feed the small sparkline in the price card with the last 40 points
      const take = Math.min(40, prices.length);
      S.spark = prices.slice(-take);
      render24hChart();
      renderPrice();
    }
    if(vols && vols.length){
      // CoinGecko total_volumes is 24h volume at timestamp; take latest point (USD)
      S.vol24USD = vols[vols.length-1];
      // update the pill under the wide chart
      const vEl = document.getElementById('vol24');
      if(vEl) vEl.textContent = fmtUSDc(S.vol24USD);
    }
  }catch(err){
    console.warn('[chart24] fetch failed:', err);
  }
}

// ===== FETCHER (Latest Block + Intervals) =====
async function fetchLatestBlocks(){
  try{
    const r = await fetch(API.blocks, { headers: { 'accept':'application/json' }});
    if(!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();
const arr = Array.isArray(j?.blocks) ? j.blocks : (Array.isArray(j) ? j : []);
S._blocksCache = arr.slice();
if (arr.length === 0) return;

const latest = arr[0];
const ts = latest.timestamp;                 // SatoNak field
S.blockHeight = latest.height || null;
S.blockHash = latest.id || null;             // SatoNak uses "id"

    if(typeof ts === 'number') {
      S.blockAgeMin = Math.max(0, Math.floor((nowSec - ts)/60));
    }
    S.blockTsSec = (typeof ts === 'number') ? ts : null;
    tickBlockAge();

    
    // Prefer SatoNak for miner first; then extras/coinbase ONLY if still unknown
fetchMinerFromSatoNak().finally(()=>{
  if (!S.miner && S.blockHash) {
      fetchMinerFromCoinbase(S.blockHash);
    }
});

    // intervals between consecutive blocks (minutes)
    const times = arr.map(b => (b.timestamp ?? b.time)).filter(t => typeof t === 'number');
    const ivals = [];
    for(let i=0;i<times.length-1;i++){
      const d = Math.abs(times[i] - times[i+1]);
      ivals.push(Math.max(0, Math.round(d/60)));
    }
    const miners = []; const hashes = []; const heights = [];
    for(let i=0;i<ivals.length;i++){
      const blk = arr[i];
      const nm = blk?.extras?.pool?.name || blk?.extras?.pool || null;
      miners.push(nm || null);
      hashes.push(blk?.id || blk?.hash || null);
      heights.push(blk?.height || null);
    }
    const newIntervals = ivals.slice(0,12).reverse();
    const newHashes = hashes.slice(0,12).reverse();
    const newMiners = miners.slice(0,12).reverse();
    const prevHashes = Array.isArray(S.intervalMinerHashes) ? S.intervalMinerHashes : [];
    const same = newHashes.length === prevHashes.length && newHashes.every((h,i)=> h===prevHashes[i]);

    S.intervals = newIntervals;

    if(!same){
      S.intervalMinerHashes = newHashes;
      S.intervalMinersFull = newMiners.map((n,i)=> n || (MINER_CACHE[newHashes[i]] || null));
      S.intervalMinersCode = S.intervalMinersFull.map(n=> n ? codeFromName(n) : '');
      S.intervalHeights = heights.slice(0,12).reverse();
      renderBlock();
      renderIntervalCanvas();
      if (S.intervals.length < 21) { ensureVisualizerHorizon(21);

                                    
  
}
      decodeNextIntervalMiner();
    } else {
      // No new block. Keep rendering and continue decoding if any unknowns remain
      renderBlock();
      renderIntervalCanvas();
      if (S.intervals.length < 21) { ensureVisualizerHorizon(21); 
 
      }
      if (S.intervalMinersFull && S.intervalMinerHashes && S.intervalMinersFull.some((n,i)=> !n && S.intervalMinerHashes[i])) {
        decodeNextIntervalMiner();
      }
    }
  }catch(err){
    console.warn('[blocks] fetch failed:', err);
  }
}

    //fetch miner name from Satonak
async function fetchMinerFromSatoNak(){
  try{
    const r = await fetch(API.miner, { headers: { accept: 'application/json' }});
    if(!r.ok) throw new Error('HTTP '+r.status);
    const j = await r.json();
    const name = j && typeof j.pool === 'string' ? j.pool : null;
    if(name && name !== 'Unknown'){
      S.miner = name;
      renderBlock();
      return name;
    }
  }catch(e){
    console.warn('[satonak/miner] failed:', e);
  }
  return null;
}

    
      // Fetch Miner Name
async function fetchMinerFromExtras(height, hash){
  try{
    if(!API.blocksExtras) return; // disabled by default (404 on public mempool.space)
    const r = await fetch(API.blocksExtras, { headers: { 'accept':'application/json' }});
    if(r.status === 404) return; // endpoint not available
    if(!r.ok) throw new Error('HTTP '+r.status);
    const list = await r.json();
    if(!Array.isArray(list)) return;
    const match = list.find(b => (b.height === height) || (hash && (b.id === hash || b.hash === hash)));
    const name = match?.extras?.pool?.name || match?.extras?.pool || null;
    if(name){ S.miner = name; renderBlock(); }
  }catch(e){
    console.debug('[blocks-extras] optional endpoint fetch failed:', e);
  }
}

async function fetchMinerFromCoinbase(hash){
  try {
    let txid = null;
    try {
      const rTxid = await fetch(`https://mempool.space/api/block/${hash}/txid/0`, { headers: { accept: 'text/plain' }});
      if (rTxid.ok) {
        txid = (await rTxid.text()).trim().replace(/"/g, '');
      }
    } catch (_) { }
    let tx = null;
    if (txid) {
      const rTx = await fetch(`https://mempool.space/api/tx/${txid}`, { headers: { accept: 'application/json' }});
      if (!rTx.ok) throw new Error('HTTP ' + rTx.status);
      tx = await rTx.json();
    } else {
      const r = await fetch(`https://mempool.space/api/block/${hash}/txs/0`, { headers: { accept: 'application/json' }});
      if (!r.ok) throw new Error('HTTP ' + r.status);
      const arr = await r.json();
      if (Array.isArray(arr) && arr.length) tx = arr[0];
    }
    const coinbaseHex = tx?.vin?.[0]?.coinbase || tx?.vin?.[0]?.scriptsig || '';
    const text = hexToAscii(coinbaseHex);
    const name = identifyPoolFromCoinbase(text);
    if (name && !S.miner) { S.miner = name; renderBlock(); }
    if (name && hash) { MINER_CACHE[hash] = name; }
  } catch(e) {
    console.warn('[coinbase] decode failed:', e);
  }
}

async function fetchNameFromCoinbase(hash){
  try{
    let txid = null;
    try{
      const rTxid = await fetch(`https://mempool.space/api/block/${hash}/txid/0`, { headers: { accept: 'text/plain' }});
      if(rTxid.ok){ txid = (await rTxid.text()).trim().replace(/"/g,''); }
    }catch(_){ }
    let tx = null;
    if(txid){
      const rTx = await fetch(`https://mempool.space/api/tx/${txid}`, { headers: { accept: 'application/json' }});
      if(!rTx.ok) throw new Error('HTTP '+rTx.status);
      tx = await rTx.json();
    } else {
      const r = await fetch(`https://mempool.space/api/block/${hash}/txs/0`, { headers: { accept: 'application/json' }});
      if(!r.ok) throw new Error('HTTP '+r.status);
      const arr = await r.json();
      if(Array.isArray(arr) && arr.length) tx = arr[0];
    }
    const coinbaseHex = tx?.vin?.[0]?.coinbase || tx?.vin?.[0]?.scriptsig || '';
    const text = hexToAscii(coinbaseHex);
    const name = identifyPoolFromCoinbase(text);
    return name || null;
  }catch(e){
    console.warn('[coinbase-name] failed:', e);
    return null;
  }
}

function decodeNextIntervalMiner(){
  if(!Array.isArray(S.intervalMinerHashes)) return;
  const idx = S.intervalMinersFull.findIndex((n,i)=> !n && S.intervalMinerHashes[i]);
  if(idx === -1) return; // all known
  fetchNameFromCoinbase(S.intervalMinerHashes[idx]).then(name=>{
    if(name){
      S.intervalMinersFull[idx] = name;
      S.intervalMinersCode[idx] = codeFromName(name);
      const h = S.intervalMinerHashes && S.intervalMinerHashes[idx];
      if(h) MINER_CACHE[h] = name;
      renderBlock();
  renderIntervalCanvas();
}
    setTimeout(decodeNextIntervalMiner, 400);
  }).catch(()=> setTimeout(decodeNextIntervalMiner, 400));
}


// Fetch mempool/fee data from mempool.space
async function fetchMempoolFees() {
  try {
    // Fetch fee recommendations
    const rFees = await fetch('https://mempool.space/api/v1/fees/recommended', { headers: { accept: 'application/json' } });
    if (!rFees.ok) throw new Error('Fee API error');
    const fees = await rFees.json();

    // Fetch mempool info
    const rMempool = await fetch('https://mempool.space/api/mempool', { headers: { accept: 'application/json' } });
    if (!rMempool.ok) throw new Error('Mempool API error');
    const mempool = await rMempool.json();

    // Update S.fees with live data
    S.fees.low = fees.minimumFee || fees.hourFee || null;
    S.fees.med = fees.halfHourFee || null;
    S.fees.high = fees.fastestFee || null;
    S.fees.vmb = mempool.vsize ? Math.round(mempool.vsize / 1e6 * 4) / 4 : null; // vMB, rounded to nearest 0.25
    S.fees.backlogTx = mempool.count || null;
    S.fees.capacityPct = mempool.vsize ? Math.round((mempool.vsize / 300_000_000) * 100) : null; // 300M vbytes = 300 vMB

    renderMempool();
  } catch (e) {
    console.warn('[mempool/fees] fetch failed:', e);
  }
}

// Fetch Hashrate and Difficulty

/* removed duplicate fetchHashrateAndDifficulty (consolidated) */



// Build intervals + labels from the cached block list (newest→oldest in _blocksCache)
function rebuildFromCache(){
  const arr = Array.isArray(S._blocksCache) ? S._blocksCache : [];
  if (!arr.length) return;
  // intervals between consecutive blocks (minutes)
  const times = arr.map(b => (b.timestamp ?? b.time)).filter(t => typeof t === 'number');
  const ivals = [];
  for (let i=0;i<times.length-1;i++){ ivals.push(Math.max(0, Math.round(Math.abs(times[i]-times[i+1])/60))); }
  const miners = []; const hashes = []; const heights = [];
  for (let i=0;i<ivals.length;i++){
    const blk = arr[i];
    const nm = blk?.miner?.name || null;         // SatoNak provides miner.name
    miners.push(nm || null);
    hashes.push(blk?.id || null);                // "id" only
    heights.push(blk?.height || null);

  }
  // Oldest → newest for UI
  S.intervals = ivals.slice().reverse();
  S.intervalMinerHashes = hashes.slice().reverse();
  S.intervalHeights = heights.slice().reverse();
  // Seed miner names from cache or extras
  S.intervalMinersFull = S.intervalMinerHashes.map((h,idx)=> miners[ivals.length-1-idx] || (MINER_CACHE[h]||null));
  S.intervalMinersCode = S.intervalMinersFull.map(n=> n ? codeFromName(n) : '');
  renderBlock();
  renderIntervalCanvas();
}

// Fetch one older page (10 blocks before the oldest we have) and extend cache
async function fetchOlderBlocksPage(){
  try{
    const cache = Array.isArray(S._blocksCache) ? S._blocksCache : [];
    const tail = cache[cache.length-1];
    const startH = tail?.height ? (tail.height - 1) : null;
    if (startH == null) return false;

    const url = `${SATONAK}/v1/blocks?limit=10&before_height=${startH}`;
    const r = await fetch(url, { headers: { accept:'application/json' }});
    if(!r.ok) return false;

    const j = await r.json();
    const older = Array.isArray(j?.blocks) ? j.blocks : (Array.isArray(j) ? j : []);
    if(!older.length) return false;

    cache.push(...older);              // keep newest→oldest order
    S._blocksCache = cache;
    rebuildFromCache();
    renderIntervalCanvas();
    decodeNextIntervalMiner();
    return true;
  }catch(e){
    console.warn('[older] fetch failed:', e);
    return false;
  }
}


// Ensure we have at least N intervals for the visualizer by paging older blocks on demand
async function ensureVisualizerHorizon(n=21){
  try{
    let guard = 3; // prevent unbounded paging
    while(Array.isArray(S.intervals) && S.intervals.length < n && guard-- > 0){
      const ok = await fetchOlderBlocksPage();
      if(!ok) break;
    }
    renderIntervalCanvas();
  }catch(e){ console.warn('[ensureVisualizerHorizon] failed:', e); }
}


// ===== MARKET / DOMINANCE / SUPPLY / ATH =====
async function fetchMarketMeta(){
  try{
    const isFile = (location.protocol === 'file:');

    // Circulating supply (BTC) — blockchain.info returns total satoshis (CORS OK with ?cors=true)
    const rCirc = await fetch('https://blockchain.info/q/totalbc?cors=true', { headers: { accept:'text/plain' } });
    if (rCirc.ok) {
      const satsText = await rCirc.text();
      const sats = Number(satsText.trim());
      if (isFinite(sats)) S.circBTC = sats / 1e8;
    }

    async function loadFromGecko(){
      // Dominance + global
      const rGlobal = await fetch('https://api.coingecko.com/api/v3/global', { headers: { accept:'application/json' } });
      if (rGlobal.ok){
        const g = await rGlobal.json();
        const dom = g?.data?.market_cap_percentage?.btc;
        if (isFinite(dom)) S.dominance = dom;
      }
      // Simple price + market cap
      const rSimple = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd&include_market_cap=true', { headers:{ accept:'application/json' } });
      if (rSimple.ok){
        const j = await rSimple.json();
        const b = j?.bitcoin;
        if (b){
          S.priceUSD = b.usd ?? S.priceUSD;
          S.marketCapUSD = b.usd_market_cap ?? null;
        }
      }
      // ATH info
      const rAth = await fetch('https://api.coingecko.com/api/v3/coins/bitcoin?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false', { headers:{ accept:'application/json' } });
      if (rAth.ok){
        const c = await rAth.json();
        const md = c?.market_data;
        if (md){
          S.athUSD = md?.ath?.usd ?? null;
          S.athDate = md?.ath_date?.usd ?? null;
          const p = md?.ath_change_percentage?.usd;
          if (typeof p === 'number' && isFinite(p)) S.fromAthPct = p;
        }
      }
    }

    async function loadFromPaprikaLore(){
      // Dominance (Coinlore)
      const rGlobal = await fetch('https://api.coinlore.net/api/global/?cors=1', { headers: { accept:'application/json' } });
      if (rGlobal.ok){
        const g = await rGlobal.json();
        const dom = g?.[0]?.btc_d ?? g?.btc_d;
        if (isFinite(dom)) S.dominance = Number(dom);
        const totalCap = g?.[0]?.total_mcap ?? g?.total_mcap;
        if (isFinite(totalCap)) S.totalMarketCapUSD = Number(totalCap);
      }

      // Price/cap/ATH (Coinpaprika)
      const rTicker = await fetch('https://api.coinpaprika.com/v1/tickers/btc-bitcoin', { headers:{ accept:'application/json' } });
      if (rTicker.ok){
        const t = await rTicker.json();
        const q = t?.quotes?.USD;
        if (q){
          S.priceUSD = (typeof q.price === 'number') ? q.price : S.priceUSD;
          S.marketCapUSD = (typeof q.market_cap === 'number') ? q.market_cap : null;
        }
        const ath = (typeof t?.ath_price === 'number') ? t.ath_price : (typeof t?.quotes?.USD?.ath_price === 'number' ? t.quotes.USD.ath_price : null);
        const athDate = t?.ath_date ?? t?.quotes?.USD?.ath_date ?? null;
        if (ath != null) S.athUSD = ath;
        if (athDate) S.athDate = athDate;
        const pf = t?.quotes?.USD?.percent_from_price_ath;
        if (typeof pf === 'number' && isFinite(pf)) {
          S.fromAthPct = pf;
        } else if (S.athUSD && S.priceUSD) {
          S.fromAthPct = ((S.priceUSD - S.athUSD) / S.athUSD) * 100;
        }
      }
    }

    if (!isFile) {
      // Try Gecko first in production; if it throws (CORS/rate limit), fallback
      try { await loadFromGecko(); }
      catch (e) { await loadFromPaprikaLore(); }
    } else {
      // Local file => use CORS-friendly providers
      await loadFromPaprikaLore();
    }

    renderMarket();
  }catch(e){
    console.warn('[market] fetch failed:', e);
  }
}

function daysAgoStr(iso){
  if (!iso) return '';
  const t = Date.parse(iso);
  if (!isFinite(t)) return '';
  const d = Math.max(0, Math.floor((Date.now()-t)/86400000));
  return d+'d ago';
}

function renderMarket(){
  // Locate the "Market" card by its title
  const header = Array.from(document.querySelectorAll('.card .title h3')).find(h => /Market/i.test(h.textContent));
  const marketCard = header ? header.closest('.card') : null;
  if (!marketCard) return;

  // Ensure slots
  let domEl = document.getElementById('dominance');
  if (!domEl) {
    domEl = document.createElement('div');
    domEl.id = 'dominance';
    domEl.className = 'value';
    marketCard.appendChild(domEl);
  }
  let mcEl = document.getElementById('market-cap');
  if (!mcEl) {
    mcEl = document.createElement('div');
    mcEl.id = 'market-cap';
    mcEl.className = 'sub';
    marketCard.appendChild(mcEl);
  }
  // Circulating supply row
  let circEl = document.getElementById('circ-supply');
  if (!circEl) {
    circEl = document.createElement('div');
    circEl.id = 'circ-supply';
    circEl.className = 'sub';
    marketCard.appendChild(circEl);
  }
  // ATH line and date
  let athLine = document.getElementById('ath-line');
  if (!athLine) {
    athLine = document.createElement('div');
    athLine.id = 'ath-line';
    athLine.className = 'sub';
    marketCard.appendChild(athLine);
  }
  let athDate = document.getElementById('ath-date');
  if (!athDate) {
    athDate = document.createElement('div');
    athDate.id = 'ath-date';
    athDate.className = 'sub';
    marketCard.appendChild(athDate);
  }

  // Fill values
  if (typeof S.dominance === 'number') {
    domEl.textContent = S.dominance.toFixed(1) + '% DOM';
  } else {
    domEl.textContent = '—% DOM';
  }
  const cap = S.marketCapUSD;
  mcEl.textContent = 'Cap: ' + (cap ? new Intl.NumberFormat(undefined, { style:'currency', currency:'USD', notation:'compact', maximumFractionDigits:1 }).format(cap) : '—');

  const circ = (typeof S.circBTC === 'number') ? S.circBTC : null;
  circEl.textContent = 'Circulating: ' + (circ != null ? circ.toLocaleString(undefined, { maximumFractionDigits:0 }) : '—') + ' / 21,000,000';

  // ATH line: "ATH: $XX,XXX  ▼YY.YY%"
  const ath = S.athUSD;
  const fromAth = (typeof S.fromAthPct === 'number') ? S.fromAthPct : null; // negative if below ATH per CoinGecko
  if (ath) {
    const pct = (fromAth != null) ? Math.abs(fromAth).toFixed(2) + '%' : '—';
    const down = (fromAth != null) ? (fromAth < 0) : true; // below ATH => negative
    const arrow = down ? '▼' : '▲';
    const color = down ? 'var(--bad)' : 'var(--ok)';
    athLine.innerHTML = `ATH: <b>${new Intl.NumberFormat(undefined, { style:'currency', currency:'USD' }).format(ath)}</b> <span style="color:${color}">${arrow}${pct}</span>`;
  } else {
    athLine.textContent = 'ATH: —';
  }
  // Date of ATH with days ago
  if (S.athDate) {
    const d = new Date(S.athDate);
    const label = d.toLocaleDateString(undefined, { month:'short', day:'numeric', year:'numeric' });
    athDate.textContent = `${label} (${daysAgoStr(S.athDate)})`;
  } else {
    athDate.textContent = '';
  }
}

// ===== RENDERERS =====
const $ = (q)=> document.querySelector(q);
const fmt = (n)=> n.toLocaleString(undefined, {maximumFractionDigits:0});
const fmtUSD = (n)=> n.toLocaleString(undefined, {style:'currency', currency:'USD'});
const fmtUSDc = (n)=> new Intl.NumberFormat(undefined, {style:'currency', currency:'USD', notation:'compact', maximumFractionDigits:1}).format(n || 0);

function renderPrice(){
  $('#price').textContent = fmtUSD(S.priceUSD || 0);
  const ch = Number(S.change24||0); const s = `${ch>0?'+':''}${ch.toFixed(2)}%`;
  const pill = $('#price-change');
  pill.textContent = '24h: '+ s;
  pill.style.color = ch>=0 ? 'var(--ok)' : 'var(--bad)';
  $('#price-sub').textContent = `CAD est: ${fmtUSD(S.priceCAD||0).replace('US$','$')}  ·  Last update just now`;
  if(Array.isArray(S.spark) && S.spark.length>1){
    const min = Math.min(...S.spark), max = Math.max(...S.spark);
    const pts = S.spark.map((v,i)=>{
      const x = (i/(S.spark.length-1))*100; const y = 100 - ((v-min)/(max-min))*100; return `${x},${y}`;
    }).join(' ');
    $('#sparkline').innerHTML = `<svg viewBox="0 0 100 100" preserveAspectRatio="none">
      <polyline points="${pts}" stroke-width="3" fill="none" />
    </svg>`;
  }
  if (S.priceUSD && S.priceUSD > 0) {
    const satsPerUsd = Math.floor(100000000 / S.priceUSD);
    $('#sats-per-usd').textContent = satsPerUsd.toLocaleString() + ' SATS / $1 USD';
    if (S.priceCAD && S.priceCAD > 0) {
      const satsPerCad = Math.floor(100000000 / S.priceCAD);
      $('#sats-per-cad').textContent = satsPerCad.toLocaleString() + ' SATS / $1 CAD';
    } else {
      $('#sats-per-cad').textContent = '— SATS / $1 CAD';
    }
  } else {
    $('#sats-per-usd').textContent = '— SATS / $1 USD';
    $('#sats-per-cad').textContent = '— SATS / $1 CAD';
  }
}


function renderBlock(){
  if (typeof S.blockHeight === 'number' && S.blockHeight > 0) {
    $('#block-height').textContent = 'Block ' + String(S.blockHeight ?? '—');
  } else {
    $('#block-height').textContent = 'Block —';
  }
  if (typeof S.blockAgeMin === 'number' && S.blockAgeMin >= 0) {
    $('#block-age').textContent = `mined ${S.blockAgeMin}min ago`;
  } else {
    $('#block-age').textContent = 'age —';
  }
  $('#miner').textContent = S.miner ? S.miner : '—';
  const barsEl = $('#interval-bars');
  barsEl.innerHTML = '';
  if (Array.isArray(S.intervals) && S.intervals.length) {
    const size = (S.barWindow && S.barWindow.size) ? S.barWindow.size : 7;
    const total = S.intervals.length;
    const maxStart = Math.max(0, total - size);
    const start = Math.min(Math.max((S.barWindow && S.barWindow.start) || 0, 0), maxStart);
    S.barWindow.start = start;
    const from = Math.max(0, total - size - start);
    const to = Math.max(0, total - start);
    const ints = S.intervals.slice(from, to);
    const codes = (S.intervalMinersCode||[]).slice(from, to);
    const fulls = (S.intervalMinersFull||[]).slice(from, to);
    const heights = (S.intervalHeights||[]).slice(from, to);

    const html = ints.map((v,idx)=>{
      const opacity = v < 8 ? 0.35 : (v <= 12 ? 0.55 : 0.75);
      const h = Math.min(70, v*5);
      const code = codes[idx] || '';
      const full = fulls[idx] || '';
      const ht = heights[idx] ? fmt(heights[idx]) : '';
      return `<div class=\"barwrap\"><div class=\"bar\" title=\"${v}m — ${full}\" style=\"height:${h}px; opacity:${opacity}\"></div><div class=\"barlbl\"><b>${code || '·'}</b><div class=\"ht\">${ht}</div></div></div>`;
    }).join('');
    barsEl.innerHTML = html;

    const l = document.getElementById('bars-left');
    const r = document.getElementById('bars-right');
    const j = document.getElementById('bars-latest');
    if (l) l.disabled = false;
    if (r) r.disabled = (start <= 0);
    if (j) j.style.display = (start > 0) ? 'inline-block' : 'none';
  }
}

function renderMempool(){
  $('#fee-low').textContent = S.fees.low ?? '—';
  $('#fee-med').textContent = S.fees.med ?? '—';
  $('#fee-high').textContent = S.fees.high ?? '—';
  $('#vmb').textContent = S.fees.vmb ?? '—';
  $('#tx-backlog').textContent = S.fees.backlogTx ? fmt(S.fees.backlogTx) + ' TXs' : '—';
  const pct = Math.max(0, Math.min(100, S.fees.capacityPct||0));
  const gauge = $('#mempool-gauge');
  gauge.style.setProperty('--pct', pct+'%');
  $('#gauge-pct').textContent = pct + '%';
}



/* removed duplicate renderHashMarket (consolidated) */


function render24hChart(){
  const el = document.getElementById('chart-24h');
  const W = el.clientWidth || 900, H = el.clientHeight || 180;
  if(!Array.isArray(S.chart24) || S.chart24.length<2){ el.innerHTML=''; return; }
  const min = Math.min(...S.chart24), max = Math.max(...S.chart24);
  const pts = S.chart24.map((v,i)=>{
    const x = (i/(S.chart24.length-1))*W; const y = H - ((v-min)/(max-min))*H; return `${x},${y}`
  }).join(' ');
  el.innerHTML = `<svg viewBox="0 0 ${W} ${H}" width="100%" height="100%">
    <defs>
      <linearGradient id="g1" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="${getComputedStyle(document.documentElement).getPropertyValue('--accent')}" stop-opacity=".5"/>
        <stop offset="100%" stop-color="transparent" stop-opacity="0"/>
      </linearGradient>
    </defs>
    <polyline points="${pts}" stroke="var(--accent)" stroke-width="3" fill="none"/>
    <polyline points="${pts} ${W},${H} 0,${H}" fill="url(#g1)" />
    <line x1="0" y1="${H/2}" x2="${W}" y2="${H/2}" stroke="#1f2a37" stroke-dasharray="4 6"/>
  </svg>`;
  document.getElementById('low24').textContent = fmtUSD(min);
  document.getElementById('high24').textContent = fmtUSD(max);
  document.getElementById('vol24').textContent = S.vol24USD ? fmtUSDc(S.vol24USD) : '—';
}

function humanBytes(n){
  if(n == null || isNaN(n)) return '—';
  const units = ['B','KB','MB','GB'];
  let i=0, v=n;
  while(v>=1024 && i<units.length-1){ v/=1024; i++; }
  return (i<=1 ? v.toFixed(0) : v.toFixed(2)) + ' ' + units[i];
}

async function fetchBlockDetail(hash){
  if(!hash || DETAILS_CACHE[hash] || DETAILS_FETCHING.has(hash)) return;
  DETAILS_FETCHING.add(hash);
  try{
    const r = await fetch(`${API_BASE}/block/${hash}`, { headers:{ accept:'application/json' }});
    if(r.ok){
      const j = await r.json();
      const sizeBytes = j?.size ?? null;
      const txCount = j?.tx_count ?? j?.txCount ?? null;
      DETAILS_CACHE[hash] = { sizeBytes, txCount };
      renderIntervalCanvas(); // re-render once data arrives
    }
  }catch(e){ console.warn('[detail] fetch failed for', hash, e); }
  finally{ DETAILS_FETCHING.delete(hash); }
}

function renderIntervalCanvas(){
  const el = document.getElementById('interval-canvas');
  const W = el.clientWidth || 1000, H = el.clientHeight || 180;

  // Determine how many columns can fit while keeping labels readable
  const IVfull = Array.isArray(S.intervals) ? S.intervals : [];
  const HHfull = Array.isArray(S.intervalHeights) ? S.intervalHeights : [];
  const HSfull = Array.isArray(S.intervalMinerHashes) ? S.intervalMinerHashes : [];
  if(!IVfull.length){ el.innerHTML=''; return; }

  // Colors: match price sparkline (which uses accent-alt)
  const cs = getComputedStyle(document.documentElement);
  const alt = (cs.getPropertyValue('--accent-alt') || '#00f6ff').trim();
  const main = (cs.getPropertyValue('--accent') || '#ffa600').trim();

  // Layout + density
  const padTop = 10;
  const labelBand = 34; // two-line band inside each bar
  const minBar = labelBand + 8; // ensure even smallest bars have room
  const gap = 4;
  const minBW = 54; // minimum column width so labels stay readable
  const maxColsByWidth = Math.max(6, Math.floor((W + gap) / (minBW + gap)));
  const COLS = Math.min(21, maxColsByWidth, IVfull.length);
  const IV = IVfull.slice(-COLS);
  const HH = HHfull.slice(-COLS);
  const HS = HSfull.slice(-COLS);
  const bw = Math.max(minBW, Math.floor((W - (COLS-1)*gap) / COLS));
  const maxM = Math.min(30, Math.max(12, Math.max(...IV))); // clamp scale 12–30m for sanity

  // Build SVG
  const g = [`<svg viewBox=\"0 0 ${W} ${H}\" width=\"100%\" height=\"100%\">`];
  // Gradient using alt accent
  g.push(`<defs><linearGradient id=\"vizgrad\" x1=\"0\" x2=\"0\" y1=\"0\" y2=\"1\">`+
         `<stop offset=\"0%\" stop-color=\"${alt}\" stop-opacity=\".65\"/>`+
         `<stop offset=\"100%\" stop-color=\"${alt}\" stop-opacity=\".12\"/>`+
         `</linearGradient></defs>`);

  // 10-min target line
  const frac10 = Math.sqrt(10 / maxM);
  const h10 = Math.max(minBar, Math.round(frac10 * (H - padTop - 4)));
  const y10 = H - h10;
  g.push(`<line x1="0" y1="${y10}" x2="${W}" y2="${y10}" stroke="${main}" stroke-opacity=".6" stroke-width="1.5" stroke-dasharray="6 6"/>`);
  
  
  // Bars
  let x = 0;
  const labelBoxHeight = 22; // px, fixed height for label box
  for(let i=0;i<IV.length;i++){
    const m = IV[i];
    //const frac = Math.max(0, Math.min(1, m / maxM));
    const frac = Math.sqrt(m / maxM); // square root scale for better visibility
    const h = Math.max(minBar, Math.round(frac * (H - padTop - 4)));
    const y = H - h;
    const hash = HS[i];

    // Try to read details from cached block list first
    let sizeBytes = null, txCount = null;
    if (Array.isArray(S._blocksCache) && S._blocksCache.length){
      const match = S._blocksCache.find(b => (hash && (b.id===hash || b.hash===hash)) || (HH[i] && b.height===HH[i]));
      if(match){ sizeBytes = match.size ?? null; txCount = match.tx_count ?? match.txCount ?? null; }
    }
    const fromCache = DETAILS_CACHE[hash];
    if(fromCache){ sizeBytes = sizeBytes ?? fromCache.sizeBytes; txCount = txCount ?? fromCache.txCount; }
    if(hash && (sizeBytes==null || txCount==null)) fetchBlockDetail(hash);

    // Only show block height in the label box for clarity
    const blockHeight = HH[i] ? String(HH[i]) : '—';

    // ...inside the for loop...
let sizeLabel = humanBytes(sizeBytes);
const txLabel = (txCount!=null) ? (txCount).toLocaleString() + ' tx' : '— tx';

const labelY = H - labelBoxHeight;


g.push(`<g>
  <title>${m} min • Block ${blockHeight}\n${sizeLabel} • ${txLabel}</title>
  <rect x="${x}" y="${y}" width="${bw}" height="${h}" fill="url(#vizgrad)" stroke="#1f2a37"/>
  <rect x="${x}" y="${labelY}" width="${bw}" height="${labelBoxHeight}" rx="6" fill="rgba(20,25,34,0.82)" stroke="#243142"/>
  <text x="${x + bw/2}" y="${labelY + 14}" text-anchor="middle" font-family="'JetBrains Mono', monospace" font-size="12" fill="#ffffff">${blockHeight}</text>
</g>`);

    x += bw + gap;
  }
  g.push(`</svg>`);
  el.innerHTML = g.join('\n');
}

function tickBlockAge(){
  if (typeof S.blockTsSec === 'number') {
    const nowSec = Math.floor(Date.now()/1000);
    const mins = Math.max(0, Math.floor((nowSec - S.blockTsSec)/60));
    if (mins !== S.blockAgeMin) {
      S.blockAgeMin = mins;
      const el = document.getElementById('block-age');
      if (el) el.textContent = `mined ${S.blockAgeMin}min ago`;
    }
  }
}

// ===== LOOPS =====    
function startBlockLoop(){
  fetchLatestBlocks();
  clearInterval(tBlock); clearInterval(tBlockAge);
  tBlock = setInterval(fetchLatestBlocks, 30_000);
  tBlockAge = setInterval(tickBlockAge, 15_000);
}

function startPriceLoop(){
  clearInterval(tPrice); clearInterval(tChart);
  fetchPriceAndChange();
  fetchChart24h();
  tPrice = setInterval(fetchPriceAndChange, 30_000);
  tChart = setInterval(fetchChart24h, 120_000);
  fetchMempoolFees();
  setInterval(fetchMempoolFees, 30000); // update every 30 seconds
  fetchHashrateAndDifficulty();
  setInterval(fetchHashrateAndDifficulty, 30000); // update every 30 seconds
}

    // Render all dynamic components
function renderAll(){
      renderPrice();
      renderBlock();
      renderMempool();
      renderHashMarket();
      render24hChart();
      renderIntervalCanvas();
    }

    // Theme toggle (swap accent colors)
    function setAccent(hex){
      const r = document.documentElement;
      r.style.setProperty('--accent', hex);
      if(hex.toLowerCase()==='#ffa600'){
        // main = amber, alt = cyan
        r.style.setProperty('--glow-color','rgba(255,166,0,.35)');
        r.style.setProperty('--bar1','rgba(255,166,0,.6)');
        r.style.setProperty('--bar2','rgba(255,166,0,.1)');
        r.style.setProperty('--accent-alt','#00f6ff');
        r.style.setProperty('--glow-alt-color','rgba(0,246,255,.35)');
      } else {
        // main = cyan, alt = amber
        r.style.setProperty('--glow-color','rgba(0,246,255,.35)');
        r.style.setProperty('--bar1','rgba(0,246,255,.6)');
        r.style.setProperty('--bar2','rgba(0,246,255,.1)');
        r.style.setProperty('--accent-alt','#ffa600');
        r.style.setProperty('--glow-alt-color','rgba(255,166,0,.35)');
      }
    }

    document.getElementById('theme').addEventListener('click', ()=>{
      const cur = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim().toLowerCase();
      setAccent(cur === '#ffa600' ? '#00f6ff' : '#ffa600');
      renderAll();
    });

    document.getElementById('mode').addEventListener('click', ()=>{
      document.documentElement.classList.toggle('light');
      renderAll();
    });
    document.getElementById('refresh').addEventListener('click', ()=>{
  // Real fetches
  fetchPriceAndChange();
  fetchChart24h();
  fetchLatestBlocks();
  fetchMempoolFees();
  fetchHashrateAndDifficulty();
});

    // Arrow controls for interval bar window (7 visible out of last 12)
    (function(){
      const leftBtn = document.getElementById('bars-left');
      const rightBtn = document.getElementById('bars-right');
      if (leftBtn) leftBtn.addEventListener('click', async ()=>{
        const total = S.intervals.length;
        const size = (S.barWindow && S.barWindow.size) ? S.barWindow.size : 7;
        const maxStart = Math.max(0, total - size);
        const cur = S.barWindow.start || 0;
        if (cur < maxStart){
          S.barWindow.start = cur + 1;
          renderBlock();
        } else {
          // At oldest window; try to load older blocks
          leftBtn.disabled = true;
          const ok = await fetchOlderBlocksPage();
          leftBtn.disabled = false;
          if (ok){
            const newTotal = S.intervals.length;
            const newMax = Math.max(0, newTotal - size);
            S.barWindow.start = Math.min(cur + 1, newMax);
            renderBlock();
          }
        }
      });
      if (rightBtn) rightBtn.addEventListener('click', ()=>{
        S.barWindow.start = Math.max((S.barWindow?.start || 0) - 1, 0);
        renderBlock();
      });
      const jumpBtn = document.getElementById('bars-latest');
      if (jumpBtn) jumpBtn.addEventListener('click', ()=>{
        S.barWindow.start = 0;
        renderBlock();
      });
    })();

    // ===== BOOTSTRAP =====
  setAccent('#ffa600');      // default accent (amber)
  renderAll();               // first paint
  startPriceLoop();          // price + 24h chart loops
  startBlockLoop();          // latest block + age ticker
  ensureVisualizerHorizon(21); 

    // NEW: pull miner immediately and on a short cadence
  fetchMinerFromSatoNak();
  setInterval(fetchMinerFromSatoNak, 30000);

  // Market/Dominance loop
  fetchMarketMeta();
  setInterval(fetchMarketMeta, 120000);
// make sure bottom visualizer has enough history
  
/* === CANONICAL OVERRIDES (hashrate + difficulty) === */
// Normalize various hashrate units to EH/s
function toEH(value, unit) {
  const n = Number(value);
  if (!isFinite(n)) return null;
  const u = (unit || '').toLowerCase();
  if (u.includes('eh')) return n;         // EH/s
  if (u.includes('ph')) return n / 1e3;   // PH/s -> EH/s
  if (u.includes('th')) return n / 1e6;   // TH/s -> EH/s
  if (u.includes('h/s')) return n / 1e18; // H/s  -> EH/s
  return n; // assume EH/s if unspecified
}

// Be strict: only accept obvious hashrate keys (avoid generic "value"/"h")
function extractHashrate(d) {
  if (!d) return null;
  const pick = (o) =>
    o.avgHashrate ?? o.averageHashrate ??
    o.currentHashrate ?? o.current_hashrate ??
    o.hashrate ?? o.avg_hashrate ?? null;

  if (Array.isArray(d)) {
    for (let i = d.length - 1; i >= 0; i--) {
      const v = pick(d[i]);
      if (isFinite(Number(v))) return Number(v);
    }
    return null;
  }
  if (Array.isArray(d.series)) return extractHashrate(d.series);
  const v = pick(d);
  return isFinite(Number(v)) ? Number(v) : null;
}

// Robust, single source of truth
async function fetchHashrateAndDifficulty() {

  const GS = (typeof S !== 'undefined') ? S : (window.S = window.S || {});
  try {
    // --- Hashrate (3d) ---
    const rHash = await fetch('https://mempool.space/api/v1/mining/hashrate/3d', { headers:{accept:'application/json'} });
    if (!rHash.ok) throw new Error('hashrate HTTP ' + rHash.status);
    const hashData = await rHash.json();

    function pick(o){
      return o?.avgHashrate ?? o?.averageHashrate ?? o?.currentHashrate ?? o?.current_hashrate ?? o?.hashrate ?? o?.avg_hashrate ?? null;
    }
    let hr = null, series = null;
    if (Array.isArray(hashData?.series)) series = hashData.series;
    else if (Array.isArray(hashData)) series = hashData;

    if (series && series.length) {
      for (let i = series.length - 1; i >= 0; i--) {
        const v = pick(series[i]);
        if (isFinite(Number(v))) { hr = Number(v); break; }
      }
    } else {
      const v = pick(hashData);
      if (isFinite(Number(v))) hr = Number(v);
    }

    let unit =
      hashData.unit || hashData.units ||
      (Array.isArray(hashData?.series) && hashData.series[0]?.unit) ||
      (Array.isArray(hashData) && hashData[0]?.unit) || null;

    // Infer unit if omitted and magnitude is clearly raw H/s
    if (!unit && typeof hr === 'number' && isFinite(hr) && hr > 1e12) unit = 'h/s';
    const hrEH = unit ? toEH(hr, unit) : hr;

    
    // Compute a true 24h change from the series (prefer timestamps)
    let pct24 = null;
    if (series && series.length >= 2) {
      const getT = (pt)=> {
        const t = Number(pt?.timestamp ?? pt?.time ?? pt?.t ?? null);
        if (!isFinite(t)) return null;
        return t > 1e12 ? Math.round(t/1000) : t;
      };
      // latest valid point
      let idxNow = -1, hrNow = null, tNow = null;
      for (let i = series.length - 1; i >= 0; i--) {
        const v = pick(series[i]); const t = getT(series[i]);
        if (isFinite(Number(v)) && t) { idxNow = i; hrNow = Number(v); tNow = t; break; }
      }
      if (idxNow >= 0) {
        const target = tNow - 86400;
        // choose the point with the *closest* timestamp to (tNow-86400)
        let bestIdx = -1, bestDt = Infinity, hrPrev = null;
        for (let j = idxNow - 1; j >= 0; j--) {
          const vj = pick(series[j]); const tj = getT(series[j]);
          if (!isFinite(Number(vj)) || !tj) continue;
          const dt = Math.abs(tj - target);
          if (dt < bestDt) { bestDt = dt; bestIdx = j; hrPrev = Number(vj); }
          if (tj < target && bestDt < 900) break; // stop early if within 15m
        }
        if (isFinite(hrNow) && isFinite(hrPrev) && hrPrev !== 0) {
          const nowEH = toEH(hrNow, unit || 'eh/s');
          const prevEH = toEH(hrPrev, unit || 'eh/s');
          pct24 = ((nowEH - prevEH) / prevEH) * 100;
        }
      }
      // Fallback if timestamps missing or failed: estimate cadence and use index shift
      if (pct24 == null) {
        let shift = 24; // default guess: hourly
        // estimate cadence if we have a few timestamps
        let firstT = null, lastT = null, countT = 0;
        for (let k = 0; k < series.length; k++) {
          const tt = getT(series[k]);
          if (tt) { 
            if (firstT == null) firstT = tt;
            lastT = tt; countT++;
          }
        }
        if (firstT != null && lastT != null && countT >= 3) {
          const cadence = Math.max(1, Math.round((lastT - firstT) / Math.max(1, (countT-1)))); // seconds/step
          shift = Math.max(1, Math.round(86400 / cadence));
        } else {
          // known mempool cadence possibilities: ~30min → 48 steps/day
          if (series.length >= 48) shift = 48;
        }
        const last = series.length - 1;
        const vNow = pick(series[last]);
        const vPrev = pick(series[Math.max(0, last - shift)]);
        if (isFinite(Number(vNow)) && isFinite(Number(vPrev)) && Number(vPrev) !== 0) {
          const nowEH = toEH(Number(vNow), unit || 'eh/s');
          const prevEH = toEH(Number(vPrev), unit || 'eh/s');
          pct24 = ((nowEH - prevEH) / prevEH) * 100;
        }
      }
    } else {
    
      pct24 = hashData.percentChange24h ?? hashData.percent_change_24h ?? hashData.changePercent24h ?? null;
    }

    // --- Difficulty adjustment ---
    const rDiff = await fetch('https://mempool.space/api/v1/difficulty-adjustment', { headers:{accept:'application/json'} });
    if (!rDiff.ok) throw new Error('difficulty HTTP ' + rDiff.status);
    const diffData = await rDiff.json();

    const epochSec = (x)=> {
      const n = Number(x); if (!isFinite(n)) return null;
      return n > 1e12 ? Math.round(n/1000) : n;
    };

    const prevSec =
      epochSec(diffData.previousRetarget) ??
      epochSec(diffData.previous_retarget) ??
      epochSec(diffData.lastAdjustmentTime) ??
      epochSec(diffData.last_adjustment_time) ??
      null;

    if (prevSec) {
      GS.difficultyLastDate = new Date(prevSec * 1000).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
      GS.difficultyDaysAgo = Math.max(0, Math.round((Date.now()/1000 - prevSec) / 86400));
    } else {
      const days = Number(diffData.daysSinceAdjustment ?? diffData.days_since_adjustment);
      if (isFinite(days) && days >= 0 && days <= 40) {
        GS.difficultyDaysAgo = Math.round(days);
        GS.difficultyLastDate = null;
      } else {
        GS.difficultyDaysAgo = null;
        GS.difficultyLastDate = null;
      }
    }

    // Next adjustment date + days until
    const remSec = Number(diffData.remainingTime ?? diffData.remaining_time);
    const remBlocks = Number(diffData.remainingBlocks ?? diffData.remaining_blocks);
    if (isFinite(remSec) && remSec >= 0) {
      GS.diffDays = Math.max(0, Math.round(remSec / 86400));
      GS.nextAdjDate = new Date(Date.now() + remSec * 1000).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    } else if (isFinite(remBlocks) && remBlocks >= 0) {
      const estSec = remBlocks * 600;
      GS.diffDays = Math.max(0, Math.round(estSec / 86400));
      GS.nextAdjDate = new Date(Date.now() + estSec * 1000).toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
    } else {
      GS.diffDays = null;
      GS.nextAdjDate = null;
    }

    // Epoch number (derived from latest block height if available)
    if (typeof GS.blockHeight === 'number' && isFinite(GS.blockHeight)) {
      GS.diffEpoch = Math.floor((GS.blockHeight - 1) / 2016);
    } else {
      GS.diffEpoch = null;
    }

    GS.hashrate = hrEH;
    GS.hashrate24hChange = (typeof pct24 === 'number' && isFinite(pct24)) ? pct24 : null;
    GS.difficulty =
      diffData.currentDifficulty ??
      diffData.current_difficulty ??
      diffData.difficulty ??
      null;
    GS.difficultyChange =
      diffData.difficultyChange ??
      diffData.difficulty_change ??
      diffData.changePercent ??
      diffData.change_percent ??
      null;

    if (typeof renderHashMarket === 'function') renderHashMarket();
  } catch (e) {
    console.warn('[hash/diff] fetch failed:', e);
  }

}

// Single renderer that enforces layout & formatting
function renderHashMarket(){

  const GS = (typeof S !== 'undefined') ? S : (window.S = window.S || {});
  const card = document.getElementById('card-hashrate') || document.getElementById('hashrate')?.closest('.card');
  if (!card) return;

  // Big centered hashrate
  const valEl = document.getElementById('hashrate');
  const fmtEH = n => Number(n).toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 });
  const nVal = (typeof GS.hashrate === 'number' && isFinite(GS.hashrate)) ? GS.hashrate : null;
  valEl.textContent = (nVal != null ? fmtEH(nVal) : '—') + ' EH/s';
  valEl.style.textAlign = 'center';
  valEl.style.width = '100%';

  
  // 24h inline row: ▲/▼x.xx% 24h (centered, immediately under big hashrate)
  let hrLine = document.getElementById('hashrate-24h-line');
  if (!hrLine) {
    hrLine = document.createElement('div');
    hrLine.id = 'hashrate-24h-line';
    hrLine.className = 'sub';
    hrLine.style.textAlign = 'center';
    valEl.parentNode.insertBefore(hrLine, valEl.nextSibling);
  }
  const hrChange = (typeof GS.hashrate24hChange === 'number') ? GS.hashrate24hChange : null;
  if (hrChange != null) {
    const up = hrChange > 0, down = hrChange < 0;
    const arrow = up ? '▲' : (down ? '▼' : '◆');
    const pct = Math.abs(hrChange).toFixed(2) + '%';
    const color = up ? 'var(--ok)' : (down ? 'var(--bad)' : 'var(--muted)');
    hrLine.innerHTML = `<span class="hr-arrow" style="color:${color}">${arrow}${pct}</span> <span class="hr-label" style="color:var(--muted)">24h</span>`;
  } else {
    hrLine.textContent = '';
  }

  // Spacer

  let spacer = document.getElementById('hashrate-diff-spacer');
  if (!spacer) {
    spacer = document.createElement('div');
    spacer.id = 'hashrate-diff-spacer';
    spacer.style.height = '8px';
    card.appendChild(spacer);
  }

  // DIFFICULTY title
  let diffTitle = document.getElementById('difficulty-title');
  if (!diffTitle) {
    diffTitle = document.createElement('div');
    diffTitle.id = 'difficulty-title';
    diffTitle.className = 'title';
    diffTitle.innerHTML = '<h3>Difficulty</h3>';
    card.appendChild(diffTitle);
  }

  // Difficulty Epoch
  let epochEl = document.getElementById('difficulty-epoch');
  if (!epochEl) {
    epochEl = document.createElement('div');
    epochEl.id = 'difficulty-epoch';
    epochEl.className = 'value';
    epochEl.style.textAlign = 'center';
    card.appendChild(epochEl);
  }
  if (typeof GS.diffEpoch === 'number') {
    epochEl.textContent = 'Epoch ' + GS.diffEpoch.toLocaleString();
  } else {
    epochEl.textContent = 'Epoch —';
  }

  // Difficulty % line
  let dPctEl = document.getElementById('difficulty-pct-line');
  if (!dPctEl) {
    dPctEl = document.createElement('div');
    dPctEl.id = 'difficulty-pct-line';
    dPctEl.className = 'sub';
    dPctEl.style.textAlign = 'center';
    card.appendChild(dPctEl);
  }
  const dCh = (typeof GS.difficultyChange === 'number') ? GS.difficultyChange : null;
  if (dCh != null) {
    const up = dCh > 0, down = dCh < 0;
    const arrow = up ? '▲' : (down ? '▼' : '◆');
    const pct = Math.abs(dCh).toFixed(2) + '%';
    const color = up ? 'var(--ok)' : (down ? 'var(--bad)' : 'var(--muted)');
    dPctEl.innerHTML = `<span class="d-arrow" style="color:${color}">${arrow}${pct}</span>`;
  } else {
    dPctEl.textContent = '';
  }

  // Bottom row: "# Days since" (left) and "Next adj" (right)
  let row = document.getElementById('difficulty-row');
  if (!row) {
    row = document.createElement('div');
    row.id = 'difficulty-row';
    row.style.display = 'grid';
    row.style.gridTemplateColumns = '1fr 1fr';
    row.style.marginTop = '6px';
    card.appendChild(row);
  }
  let daysEl = document.getElementById('difficulty-days');
  if (!daysEl) {
    daysEl = document.createElement('div');
    daysEl.id = 'difficulty-days';
    daysEl.className = 'sub';
    daysEl.style.textAlign = 'left';
    row.appendChild(daysEl);
  }
  let nextEl = document.getElementById('difficulty-next-date');
  if (!nextEl) {
    nextEl = document.createElement('div');
    nextEl.id = 'difficulty-next-date';
    nextEl.className = 'sub';
    nextEl.style.textAlign = 'right';
    row.appendChild(nextEl);
  }

  if (typeof GS.difficultyDaysAgo === 'number' && isFinite(GS.difficultyDaysAgo)) {
    daysEl.textContent = '# Days since: ' + GS.difficultyDaysAgo + 'd';
  } else {
    daysEl.textContent = '# Days since: —';
  }
  nextEl.textContent = 'Next adj: ' + (GS.nextAdjDate || '—');

}
/* === /CANONICAL OVERRIDES === */
</script>
</body>
</html>
